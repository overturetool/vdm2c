

/*  VERSION: For the version of VDM2C used to generate this project, refer to one of the generated files.  */


/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "basicTypes.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void VdmBoolean_Initialize(VdmBoolean* pVal)
{
    *pVal = (VdmBoolean) FALSE;
}
#endif

 
flag VdmBoolean_IsConstraintValid(const VdmBoolean* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag VdmBoolean_Equal(const VdmBoolean* pVal1, const VdmBoolean* pVal2)
{
	flag ret=TRUE;
	
	ret = ( (*pVal1 && *pVal2) || (!*pVal1 && !*pVal2));

	return ret;
}

flag VdmBoolean_Encode(const VdmBoolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? VdmBoolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,*pVal);
    }

	return ret;
}

flag VdmBoolean_Decode(VdmBoolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435457;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void VdmInteger_Initialize(VdmInteger* pVal)
{
    *pVal = (VdmInteger) 0;
}
#endif

 
flag VdmInteger_IsConstraintValid(const VdmInteger* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag VdmInteger_Equal(const VdmInteger* pVal1, const VdmInteger* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag VdmInteger_Encode(const VdmInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? VdmInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeUnConstraintWholeNumber(pBitStrm, *pVal);
    }

	return ret;
}

flag VdmInteger_Decode(VdmInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeUnConstraintWholeNumber(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435458;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void VdmReal_Initialize(VdmReal* pVal)
{
    *pVal = (VdmReal) 0.00000000000000000000E+000;
}
#endif

 
flag VdmReal_IsConstraintValid(const VdmReal* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag VdmReal_Equal(const VdmReal* pVal1, const VdmReal* pVal2)
{
	flag ret=TRUE;
	
	ret =  *pVal1 == *pVal2 ? TRUE : (*pVal1 == 0.0 ? *pVal2 ==0.0 : (fabs((*pVal1 - *pVal2) / *pVal1) < 0.00001));

	return ret;
}

flag VdmReal_Encode(const VdmReal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? VdmReal_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, *pVal);
    }

	return ret;
}

flag VdmReal_Decode(VdmReal* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435459;

	return ret;
}

